"""
This type stub file was generated by pyright.
"""

import ast
from pathlib import Path
from typing import Any, TYPE_CHECKING
from smolagents.memory import AgentLogger

if TYPE_CHECKING:
    ...
__all__ = ["AgentError"]
BASE_BUILTIN_MODULES = ...
def escape_code_brackets(text: str) -> str:
    """Escapes square brackets in code segments while preserving Rich styling tags."""
    ...

class AgentError(Exception):
    """Base class for other agent-related exceptions"""
    def __init__(self, message, logger: AgentLogger) -> None:
        ...
    
    def dict(self) -> dict[str, str]:
        ...
    


class AgentParsingError(AgentError):
    """Exception raised for errors in parsing in the agent"""
    ...


class AgentExecutionError(AgentError):
    """Exception raised for errors in execution in the agent"""
    ...


class AgentMaxStepsError(AgentError):
    """Exception raised for errors in execution in the agent"""
    ...


class AgentToolCallError(AgentExecutionError):
    """Exception raised for errors when incorrect arguments are passed to the tool"""
    ...


class AgentToolExecutionError(AgentExecutionError):
    """Exception raised for errors when executing a tool"""
    ...


class AgentGenerationError(AgentError):
    """Exception raised for errors in generation in the agent"""
    ...


def make_json_serializable(obj: Any) -> Any:
    """Recursive function to make objects JSON serializable"""
    ...

def parse_json_blob(json_blob: str) -> tuple[dict[str, str], str]:
    "Extracts the JSON blob from the input and returns the JSON data and the rest of the input."
    ...

def extract_code_from_text(text: str) -> str | None:
    """Extract code from the LLM's output."""
    ...

def parse_code_blobs(text: str) -> str:
    """Extract code blocs from the LLM's output.

    If a valid code block is passed, it returns it directly.

    Args:
        text (`str`): LLM's output text to parse.

    Returns:
        `str`: Extracted code block.

    Raises:
        ValueError: If no valid code block is found in the text.
    """
    ...

MAX_LENGTH_TRUNCATE_CONTENT = ...
def truncate_content(content: str, max_length: int = ...) -> str:
    ...

class ImportFinder(ast.NodeVisitor):
    def __init__(self) -> None:
        ...
    
    def visit_Import(self, node): # -> None:
        ...
    
    def visit_ImportFrom(self, node): # -> None:
        ...
    


def get_method_source(method): # -> str:
    """Get source code for a method, including bound methods."""
    ...

def is_same_method(method1, method2): # -> bool:
    """Compare two methods by their source code."""
    ...

def is_same_item(item1, item2): # -> bool:
    """Compare two class items (methods or attributes) for equality."""
    ...

def instance_to_source(instance, base_cls=...): # -> LiteralString:
    """Convert an instance to its class source code representation."""
    ...

def get_source(obj) -> str:
    """Get the source code of a class or callable object (e.g.: function, method).
    First attempts to get the source code using `inspect.getsource`.
    In a dynamic environment (e.g.: Jupyter, IPython), if this fails,
    falls back to retrieving the source code from the current interactive shell session.

    Args:
        obj: A class or callable object (e.g.: function, method)

    Returns:
        str: The source code of the object, dedented and stripped

    Raises:
        TypeError: If object is not a class or callable
        OSError: If source code cannot be retrieved from any source
        ValueError: If source cannot be found in IPython history

    Note:
        TODO: handle Python standard REPL
    """
    ...

def encode_image_base64(image): # -> str:
    ...

def make_image_url(base64_image): # -> str:
    ...

def make_init_file(folder: str | Path): # -> None:
    ...

def is_valid_name(name: str) -> bool:
    ...

