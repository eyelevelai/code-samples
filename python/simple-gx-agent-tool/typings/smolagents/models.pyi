"""
This type stub file was generated by pyright.
"""

from collections.abc import Generator
from dataclasses import dataclass
from enum import Enum
from typing import Any, TYPE_CHECKING
from .monitoring import TokenUsage
from .tools import Tool
from transformers import StoppingCriteriaList

if TYPE_CHECKING:
    ...
logger = ...
STRUCTURED_GENERATION_PROVIDERS = ...
CODEAGENT_RESPONSE_FORMAT = ...
def get_dict_from_nested_dataclasses(obj, ignore_key=...): # -> dict[str, dict[str, Any] | Any]:
    ...

@dataclass
class ChatMessageToolCallFunction:
    arguments: Any
    name: str
    description: str | None = ...


@dataclass
class ChatMessageToolCall:
    function: ChatMessageToolCallFunction
    id: str
    type: str
    def __str__(self) -> str:
        ...
    


@dataclass
class ChatMessage:
    role: str
    content: str | list[dict[str, Any]] | None = ...
    tool_calls: list[ChatMessageToolCall] | None = ...
    raw: Any | None = ...
    token_usage: TokenUsage | None = ...
    def model_dump_json(self): # -> str:
        ...
    
    @classmethod
    def from_dict(cls, data: dict, raw: Any | None = ..., token_usage: TokenUsage | None = ...) -> ChatMessage:
        ...
    
    def dict(self): # -> dict[str, dict[str, Any] | Any]:
        ...
    
    def render_as_markdown(self) -> str:
        ...
    


def parse_json_if_needed(arguments: str | dict) -> str | dict:
    ...

@dataclass
class ChatMessageToolCallStreamDelta:
    """Represents a streaming delta for tool calls during generation."""
    index: int | None = ...
    id: str | None = ...
    type: str | None = ...
    function: ChatMessageToolCallFunction | None = ...


@dataclass
class ChatMessageStreamDelta:
    content: str | None = ...
    tool_calls: list[ChatMessageToolCallStreamDelta] | None = ...
    token_usage: TokenUsage | None = ...


class MessageRole(str, Enum):
    USER = ...
    ASSISTANT = ...
    SYSTEM = ...
    TOOL_CALL = ...
    TOOL_RESPONSE = ...
    @classmethod
    def roles(cls): # -> list[str]:
        ...
    


def agglomerate_stream_deltas(stream_deltas: list[ChatMessageStreamDelta], role: MessageRole = ...) -> ChatMessage:
    """
    Agglomerate a list of stream deltas into a single stream delta.
    """
    ...

tool_role_conversions = ...
def get_tool_json_schema(tool: Tool) -> dict:
    ...

def remove_stop_sequences(content: str, stop_sequences: list[str]) -> str:
    ...

def get_clean_message_list(message_list: list[ChatMessage], role_conversions: dict[MessageRole, MessageRole] | dict[str, str] = ..., convert_images_to_image_urls: bool = ..., flatten_messages_as_text: bool = ...) -> list[dict[str, Any]]:
    """
    Creates a list of messages to give as input to the LLM. These messages are dictionaries and chat template compatible with transformers LLM chat template.
    Subsequent messages with the same role will be concatenated to a single message.

    Args:
        message_list (`list[dict[str, str]]`): List of chat messages.
        role_conversions (`dict[MessageRole, MessageRole]`, *optional* ): Mapping to convert roles.
        convert_images_to_image_urls (`bool`, default `False`): Whether to convert images to image URLs.
        flatten_messages_as_text (`bool`, default `False`): Whether to flatten messages as text.
    """
    ...

def get_tool_call_from_text(text: str, tool_name_key: str, tool_arguments_key: str) -> ChatMessageToolCall:
    ...

def supports_stop_parameter(model_id: str) -> bool:
    """
    Check if the model supports the `stop` parameter.

    Not supported with reasoning models openai/o3 and openai/o4-mini (and their versioned variants).

    Args:
        model_id (`str`): Model identifier (e.g. "openai/o3", "o4-mini-2025-04-16")

    Returns:
        bool: True if the model supports the stop parameter, False otherwise
    """
    ...

class Model:
    def __init__(self, flatten_messages_as_text: bool = ..., tool_name_key: str = ..., tool_arguments_key: str = ..., model_id: str | None = ..., **kwargs) -> None:
        ...
    
    @property
    def last_input_token_count(self) -> int | None:
        ...
    
    @property
    def last_output_token_count(self) -> int | None:
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        """Process the input messages and return the model's response.

        Parameters:
            messages (`list[dict[str, str | list[dict]]] | list[ChatMessage]`):
                A list of message dictionaries to be processed. Each dictionary should have the structure `{"role": "user/system", "content": "message content"}`.
            stop_sequences (`List[str]`, *optional*):
                A list of strings that will stop the generation if encountered in the model's output.
            response_format (`dict[str, str]`, *optional*):
                The response format to use in the model's response.
            tools_to_call_from (`List[Tool]`, *optional*):
                A list of tools that the model can use to generate responses.
            **kwargs:
                Additional keyword arguments to be passed to the underlying model.

        Returns:
            `ChatMessage`: A chat message object containing the model's response.
        """
        ...
    
    def __call__(self, *args, **kwargs): # -> ChatMessage:
        ...
    
    def parse_tool_calls(self, message: ChatMessage) -> ChatMessage:
        """Sometimes APIs do not return the tool call as a specific object, so we need to parse it."""
        ...
    
    def to_dict(self) -> dict:
        """
        Converts the model into a JSON-compatible dictionary.
        """
        ...
    
    @classmethod
    def from_dict(cls, model_dictionary: dict[str, Any]) -> Model:
        ...
    


class VLLMModel(Model):
    """Model to use [vLLM](https://docs.vllm.ai/) for fast LLM inference and serving.

    Parameters:
        model_id (`str`):
            The Hugging Face model ID to be used for inference.
            This can be a path or model identifier from the Hugging Face model hub.
        model_kwargs (`dict[str, Any]`, *optional*):
            Additional keyword arguments to pass to the vLLM model (like revision, max_model_len, etc.).
    """
    def __init__(self, model_id, model_kwargs: dict[str, Any] | None = ..., **kwargs) -> None:
        ...
    
    def cleanup(self): # -> None:
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    


class MLXModel(Model):
    """A class to interact with models loaded using MLX on Apple silicon.

    > [!TIP]
    > You must have `mlx-lm` installed on your machine. Please run `pip install smolagents[mlx-lm]` if it's not the case.

    Parameters:
        model_id (str):
            The Hugging Face model ID to be used for inference. This can be a path or model identifier from the Hugging Face model hub.
        tool_name_key (str):
            The key, which can usually be found in the model's chat template, for retrieving a tool name.
        tool_arguments_key (str):
            The key, which can usually be found in the model's chat template, for retrieving tool arguments.
        trust_remote_code (bool, default `False`):
            Some models on the Hub require running remote code: for this model, you would have to set this flag to True.
        load_kwargs (dict[str, Any], *optional*):
            Additional keyword arguments to pass to the `mlx.lm.load` method when loading the model and tokenizer.
        apply_chat_template_kwargs (dict, *optional*):
            Additional keyword arguments to pass to the `apply_chat_template` method of the tokenizer.
        kwargs (dict, *optional*):
            Any additional keyword arguments that you want to use in model.generate(), for instance `max_tokens`.

    Example:
    ```python
    >>> engine = MLXModel(
    ...     model_id="mlx-community/Qwen2.5-Coder-32B-Instruct-4bit",
    ...     max_tokens=10000,
    ... )
    >>> messages = [
    ...     {
    ...         "role": "user",
    ...         "content": "Explain quantum mechanics in simple terms."
    ...     }
    ... ]
    >>> response = engine(messages, stop_sequences=["END"])
    >>> print(response)
    "Quantum mechanics is the branch of physics that studies..."
    ```
    """
    def __init__(self, model_id: str, trust_remote_code: bool = ..., load_kwargs: dict[str, Any] | None = ..., apply_chat_template_kwargs: dict[str, Any] | None = ..., **kwargs) -> None:
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    


class TransformersModel(Model):
    """A class that uses Hugging Face's Transformers library for language model interaction.

    This model allows you to load and use Hugging Face's models locally using the Transformers library. It supports features like stop sequences and grammar customization.

    > [!TIP]
    > You must have `transformers` and `torch` installed on your machine. Please run `pip install smolagents[transformers]` if it's not the case.

    Parameters:
        model_id (`str`):
            The Hugging Face model ID to be used for inference. This can be a path or model identifier from the Hugging Face model hub.
            For example, `"Qwen/Qwen2.5-Coder-32B-Instruct"`.
        device_map (`str`, *optional*):
            The device_map to initialize your model with.
        torch_dtype (`str`, *optional*):
            The torch_dtype to initialize your model with.
        trust_remote_code (bool, default `False`):
            Some models on the Hub require running remote code: for this model, you would have to set this flag to True.
        kwargs (dict, *optional*):
            Any additional keyword arguments that you want to use in model.generate(), for instance `max_new_tokens` or `device`.
        **kwargs:
            Additional keyword arguments to pass to `model.generate()`, for instance `max_new_tokens` or `device`.
    Raises:
        ValueError:
            If the model name is not provided.

    Example:
    ```python
    >>> engine = TransformersModel(
    ...     model_id="Qwen/Qwen2.5-Coder-32B-Instruct",
    ...     device="cuda",
    ...     max_new_tokens=5000,
    ... )
    >>> messages = [{"role": "user", "content": "Explain quantum mechanics in simple terms."}]
    >>> response = engine(messages, stop_sequences=["END"])
    >>> print(response)
    "Quantum mechanics is the branch of physics that studies..."
    ```
    """
    def __init__(self, model_id: str | None = ..., device_map: str | None = ..., torch_dtype: str | None = ..., trust_remote_code: bool = ..., **kwargs) -> None:
        ...
    
    def make_stopping_criteria(self, stop_sequences: list[str], tokenizer) -> StoppingCriteriaList:
        class StopOnStrings(StoppingCriteria):
            ...
        
        
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    
    def generate_stream(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> Generator[ChatMessageStreamDelta]:
        ...
    


class ApiModel(Model):
    """
    Base class for API-based language models.

    This class serves as a foundation for implementing models that interact with
    external APIs. It handles the common functionality for managing model IDs,
    custom role mappings, and API client connections.

    Parameters:
        model_id (`str`):
            The identifier for the model to be used with the API.
        custom_role_conversions (`dict[str, str`], **optional**):
            Mapping to convert  between internal role names and API-specific role names. Defaults to None.
        client (`Any`, **optional**):
            Pre-configured API client instance. If not provided, a default client will be created. Defaults to None.
        **kwargs: Additional keyword arguments to pass to the parent class.
    """
    def __init__(self, model_id: str, custom_role_conversions: dict[str, str] | None = ..., client: Any | None = ..., **kwargs) -> None:
        ...
    
    def create_client(self):
        """Create the API client for the specific service."""
        ...
    


class LiteLLMModel(ApiModel):
    """Model to use [LiteLLM Python SDK](https://docs.litellm.ai/docs/#litellm-python-sdk) to access hundreds of LLMs.

    Parameters:
        model_id (`str`):
            The model identifier to use on the server (e.g. "gpt-3.5-turbo").
        api_base (`str`, *optional*):
            The base URL of the provider API to call the model.
        api_key (`str`, *optional*):
            The API key to use for authentication.
        custom_role_conversions (`dict[str, str]`, *optional*):
            Custom role conversion mapping to convert message roles in others.
            Useful for specific models that do not support specific message roles like "system".
        flatten_messages_as_text (`bool`, *optional*): Whether to flatten messages as text.
            Defaults to `True` for models that start with "ollama", "groq", "cerebras".
        **kwargs:
            Additional keyword arguments to pass to the OpenAI API.
    """
    def __init__(self, model_id: str | None = ..., api_base: str | None = ..., api_key: str | None = ..., custom_role_conversions: dict[str, str] | None = ..., flatten_messages_as_text: bool | None = ..., **kwargs) -> None:
        ...
    
    def create_client(self): # -> Any:
        """Create the LiteLLM client."""
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    
    def generate_stream(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> Generator[ChatMessageStreamDelta]:
        ...
    


class LiteLLMRouterModel(LiteLLMModel):
    """Router‑based client for interacting with the [LiteLLM Python SDK Router](https://docs.litellm.ai/docs/routing).

    This class provides a high-level interface for distributing requests among multiple language models using
    the LiteLLM SDK's routing capabilities. It is responsible for initializing and configuring the router client,
    applying custom role conversions, and managing message formatting to ensure seamless integration with various LLMs.

    Parameters:
        model_id (`str`):
            Identifier for the model group to use from the model list (e.g., "model-group-1").
        model_list (`list[dict[str, Any]]`):
            Model configurations to be used for routing.
            Each configuration should include the model group name and any necessary parameters.
            For more details, refer to the [LiteLLM Routing](https://docs.litellm.ai/docs/routing#quick-start) documentation.
        client_kwargs (`dict[str, Any]`, *optional*):
            Additional configuration parameters for the Router client. For more details, see the
            [LiteLLM Routing Configurations](https://docs.litellm.ai/docs/routing).
        custom_role_conversions (`dict[str, str]`, *optional*):
            Custom role conversion mapping to convert message roles in others.
            Useful for specific models that do not support specific message roles like "system".
        flatten_messages_as_text (`bool`, *optional*): Whether to flatten messages as text.
            Defaults to `True` for models that start with "ollama", "groq", "cerebras".
        **kwargs:
            Additional keyword arguments to pass to the LiteLLM Router completion method.

    Example:
    ```python
    >>> import os
    >>> from smolagents import CodeAgent, WebSearchTool, LiteLLMRouterModel
    >>> os.environ["OPENAI_API_KEY"] = ""
    >>> os.environ["AWS_ACCESS_KEY_ID"] = ""
    >>> os.environ["AWS_SECRET_ACCESS_KEY"] = ""
    >>> os.environ["AWS_REGION"] = ""
    >>> llm_loadbalancer_model_list = [
    ...     {
    ...         "model_name": "model-group-1",
    ...         "litellm_params": {
    ...             "model": "gpt-4o-mini",
    ...             "api_key": os.getenv("OPENAI_API_KEY"),
    ...         },
    ...     },
    ...     {
    ...         "model_name": "model-group-1",
    ...         "litellm_params": {
    ...             "model": "bedrock/anthropic.claude-3-sonnet-20240229-v1:0",
    ...             "aws_access_key_id": os.getenv("AWS_ACCESS_KEY_ID"),
    ...             "aws_secret_access_key": os.getenv("AWS_SECRET_ACCESS_KEY"),
    ...             "aws_region_name": os.getenv("AWS_REGION"),
    ...         },
    ...     },
    >>> ]
    >>> model = LiteLLMRouterModel(
    ...    model_id="model-group-1",
    ...    model_list=llm_loadbalancer_model_list,
    ...    client_kwargs={
    ...        "routing_strategy":"simple-shuffle"
    ...    }
    >>> )
    >>> agent = CodeAgent(tools=[WebSearchTool()], model=model)
    >>> agent.run("How many seconds would it take for a leopard at full speed to run through Pont des Arts?")
    ```
    """
    def __init__(self, model_id: str, model_list: list[dict[str, Any]], client_kwargs: dict[str, Any] | None = ..., custom_role_conversions: dict[str, str] | None = ..., flatten_messages_as_text: bool | None = ..., **kwargs) -> None:
        ...
    
    def create_client(self):
        ...
    


class InferenceClientModel(ApiModel):
    """A class to interact with Hugging Face's Inference Providers for language model interaction.

    This model allows you to communicate with Hugging Face's models using Inference Providers. It can be used in both serverless mode, with a dedicated endpoint, or even with a local URL, supporting features like stop sequences and grammar customization.

    Providers include Cerebras, Cohere, Fal, Fireworks, HF-Inference, Hyperbolic, Nebius, Novita, Replicate, SambaNova, Together, and more.

    Parameters:
        model_id (`str`, *optional*, default `"Qwen/Qwen2.5-Coder-32B-Instruct"`):
            The Hugging Face model ID to be used for inference.
            This can be a model identifier from the Hugging Face model hub or a URL to a deployed Inference Endpoint.
            Currently, it defaults to `"Qwen/Qwen2.5-Coder-32B-Instruct"`, but this may change in the future.
        provider (`str`, *optional*):
            Name of the provider to use for inference. A list of supported providers can be found in the [Inference Providers documentation](https://huggingface.co/docs/inference-providers/index#partners).
            Defaults to "auto" i.e. the first of the providers available for the model, sorted by the user's order [here](https://hf.co/settings/inference-providers).
            If `base_url` is passed, then `provider` is not used.
        token (`str`, *optional*):
            Token used by the Hugging Face API for authentication. This token need to be authorized 'Make calls to the serverless Inference Providers'.
            If the model is gated (like Llama-3 models), the token also needs 'Read access to contents of all public gated repos you can access'.
            If not provided, the class will try to use environment variable 'HF_TOKEN', else use the token stored in the Hugging Face CLI configuration.
        timeout (`int`, *optional*, defaults to 120):
            Timeout for the API request, in seconds.
        client_kwargs (`dict[str, Any]`, *optional*):
            Additional keyword arguments to pass to the Hugging Face InferenceClient.
        custom_role_conversions (`dict[str, str]`, *optional*):
            Custom role conversion mapping to convert message roles in others.
            Useful for specific models that do not support specific message roles like "system".
        api_key (`str`, *optional*):
            Token to use for authentication. This is a duplicated argument from `token` to make [`InferenceClientModel`]
            follow the same pattern as `openai.OpenAI` client. Cannot be used if `token` is set. Defaults to None.
        bill_to (`str`, *optional*):
            The billing account to use for the requests. By default the requests are billed on the user's account. Requests can only be billed to
            an organization the user is a member of, and which has subscribed to Enterprise Hub.
        base_url (`str`, `optional`):
            Base URL to run inference. This is a duplicated argument from `model` to make [`InferenceClientModel`]
            follow the same pattern as `openai.OpenAI` client. Cannot be used if `model` is set. Defaults to None.
        **kwargs:
            Additional keyword arguments to pass to the Hugging Face InferenceClient.

    Raises:
        ValueError:
            If the model name is not provided.

    Example:
    ```python
    >>> engine = InferenceClientModel(
    ...     model_id="Qwen/Qwen2.5-Coder-32B-Instruct",
    ...     provider="nebius",
    ...     token="your_hf_token_here",
    ...     max_tokens=5000,
    ... )
    >>> messages = [{"role": "user", "content": "Explain quantum mechanics in simple terms."}]
    >>> response = engine(messages, stop_sequences=["END"])
    >>> print(response)
    "Quantum mechanics is the branch of physics that studies..."
    ```
    """
    def __init__(self, model_id: str = ..., provider: str | None = ..., token: str | None = ..., timeout: int = ..., client_kwargs: dict[str, Any] | None = ..., custom_role_conversions: dict[str, str] | None = ..., api_key: str | None = ..., bill_to: str | None = ..., base_url: str | None = ..., **kwargs) -> None:
        ...
    
    def create_client(self): # -> InferenceClient:
        """Create the Hugging Face client."""
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    
    def generate_stream(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> Generator[ChatMessageStreamDelta]:
        ...
    


class OpenAIServerModel(ApiModel):
    """This model connects to an OpenAI-compatible API server.

    Parameters:
        model_id (`str`):
            The model identifier to use on the server (e.g. "gpt-3.5-turbo").
        api_base (`str`, *optional*):
            The base URL of the OpenAI-compatible API server.
        api_key (`str`, *optional*):
            The API key to use for authentication.
        organization (`str`, *optional*):
            The organization to use for the API request.
        project (`str`, *optional*):
            The project to use for the API request.
        client_kwargs (`dict[str, Any]`, *optional*):
            Additional keyword arguments to pass to the OpenAI client (like organization, project, max_retries etc.).
        custom_role_conversions (`dict[str, str]`, *optional*):
            Custom role conversion mapping to convert message roles in others.
            Useful for specific models that do not support specific message roles like "system".
        flatten_messages_as_text (`bool`, default `False`):
            Whether to flatten messages as text.
        **kwargs:
            Additional keyword arguments to pass to the OpenAI API.
    """
    def __init__(self, model_id: str, api_base: str | None = ..., api_key: str | None = ..., organization: str | None = ..., project: str | None = ..., client_kwargs: dict[str, Any] | None = ..., custom_role_conversions: dict[str, str] | None = ..., flatten_messages_as_text: bool = ..., **kwargs) -> None:
        ...
    
    def create_client(self): # -> OpenAI:
        ...
    
    def generate_stream(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> Generator[ChatMessageStreamDelta]:
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    


OpenAIModel = OpenAIServerModel
class AzureOpenAIServerModel(OpenAIServerModel):
    """This model connects to an Azure OpenAI deployment.

    Parameters:
        model_id (`str`):
            The model deployment name to use when connecting (e.g. "gpt-4o-mini").
        azure_endpoint (`str`, *optional*):
            The Azure endpoint, including the resource, e.g. `https://example-resource.azure.openai.com/`. If not provided, it will be inferred from the `AZURE_OPENAI_ENDPOINT` environment variable.
        api_key (`str`, *optional*):
            The API key to use for authentication. If not provided, it will be inferred from the `AZURE_OPENAI_API_KEY` environment variable.
        api_version (`str`, *optional*):
            The API version to use. If not provided, it will be inferred from the `OPENAI_API_VERSION` environment variable.
        client_kwargs (`dict[str, Any]`, *optional*):
            Additional keyword arguments to pass to the AzureOpenAI client (like organization, project, max_retries etc.).
        custom_role_conversions (`dict[str, str]`, *optional*):
            Custom role conversion mapping to convert message roles in others.
            Useful for specific models that do not support specific message roles like "system".
        **kwargs:
            Additional keyword arguments to pass to the Azure OpenAI API.
    """
    def __init__(self, model_id: str, azure_endpoint: str | None = ..., api_key: str | None = ..., api_version: str | None = ..., client_kwargs: dict[str, Any] | None = ..., custom_role_conversions: dict[str, str] | None = ..., **kwargs) -> None:
        ...
    
    def create_client(self): # -> AzureOpenAI:
        ...
    


AzureOpenAIModel = AzureOpenAIServerModel
class AmazonBedrockServerModel(ApiModel):
    """
    A model class for interacting with Amazon Bedrock Server models through the Bedrock API.

    This class provides an interface to interact with various Bedrock language models,
    allowing for customized model inference, guardrail configuration, message handling,
    and other parameters allowed by boto3 API.

    Parameters:
        model_id (`str`):
            The model identifier to use on Bedrock (e.g. "us.amazon.nova-pro-v1:0").
        client (`boto3.client`, *optional*):
            A custom boto3 client for AWS interactions. If not provided, a default client will be created.
        client_kwargs (dict[str, Any], *optional*):
            Keyword arguments used to configure the boto3 client if it needs to be created internally.
            Examples include `region_name`, `config`, or `endpoint_url`.
        custom_role_conversions (`dict[str, str]`, *optional*):
            Custom role conversion mapping to convert message roles in others.
            Useful for specific models that do not support specific message roles like "system".
            Defaults to converting all roles to "user" role to enable using all the Bedrock models.
        flatten_messages_as_text (`bool`, default `False`):
            Whether to flatten messages as text.
        **kwargs
            Additional keyword arguments passed directly to the underlying API calls.

    Example:
        Creating a model instance with default settings:
        >>> bedrock_model = AmazonBedrockServerModel(
        ...     model_id='us.amazon.nova-pro-v1:0'
        ... )

        Creating a model instance with a custom boto3 client:
        >>> import boto3
        >>> client = boto3.client('bedrock-runtime', region_name='us-west-2')
        >>> bedrock_model = AmazonBedrockServerModel(
        ...     model_id='us.amazon.nova-pro-v1:0',
        ...     client=client
        ... )

        Creating a model instance with client_kwargs for internal client creation:
        >>> bedrock_model = AmazonBedrockServerModel(
        ...     model_id='us.amazon.nova-pro-v1:0',
        ...     client_kwargs={'region_name': 'us-west-2', 'endpoint_url': 'https://custom-endpoint.com'}
        ... )

        Creating a model instance with inference and guardrail configurations:
        >>> additional_api_config = {
        ...     "inferenceConfig": {
        ...         "maxTokens": 3000
        ...     },
        ...     "guardrailConfig": {
        ...         "guardrailIdentifier": "identify1",
        ...         "guardrailVersion": 'v1'
        ...     },
        ... }
        >>> bedrock_model = AmazonBedrockServerModel(
        ...     model_id='anthropic.claude-3-haiku-20240307-v1:0',
        ...     **additional_api_config
        ... )
    """
    def __init__(self, model_id: str, client=..., client_kwargs: dict[str, Any] | None = ..., custom_role_conversions: dict[str, str] | None = ..., **kwargs) -> None:
        ...
    
    def create_client(self):
        ...
    
    def generate(self, messages: list[ChatMessage], stop_sequences: list[str] | None = ..., response_format: dict[str, str] | None = ..., tools_to_call_from: list[Tool] | None = ..., **kwargs) -> ChatMessage:
        ...
    


AmazonBedrockModel = AmazonBedrockServerModel
__all__ = ["MessageRole", "tool_role_conversions", "get_clean_message_list", "Model", "MLXModel", "TransformersModel", "ApiModel", "InferenceClientModel", "LiteLLMModel", "LiteLLMRouterModel", "OpenAIServerModel", "OpenAIModel", "VLLMModel", "AzureOpenAIServerModel", "AzureOpenAIModel", "AmazonBedrockServerModel", "AmazonBedrockModel", "ChatMessage"]
