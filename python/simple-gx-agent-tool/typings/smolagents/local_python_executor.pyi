"""
This type stub file was generated by pyright.
"""

import ast
from collections.abc import Callable
from typing import Any
from .tools import Tool

logger = ...
class InterpreterError(ValueError):
    """
    An error raised when the interpreter cannot evaluate a Python expression, due to syntax error or unsupported
    operations.
    """
    ...


ERRORS = ...
DEFAULT_MAX_LEN_OUTPUT = ...
MAX_OPERATIONS = ...
MAX_WHILE_ITERATIONS = ...
def custom_print(*args): # -> None:
    ...

def nodunder_getattr(obj, name, default=...): # -> Any | None:
    ...

BASE_PYTHON_TOOLS = ...
DANGEROUS_MODULES = ...
DANGEROUS_FUNCTIONS = ...
def check_safer_result(result: Any, static_tools: dict[str, Callable] = ..., authorized_imports: list[str] = ...): # -> None:
    """
    Checks if a result is safer according to authorized imports and static tools.

    Args:
        result (Any): The result to check.
        static_tools (dict[str, Callable]): Dictionary of static tools.
        authorized_imports (list[str]): List of authorized imports.

    Raises:
        InterpreterError: If the result is not safe
    """
    ...

def safer_eval(func: Callable): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """
    Decorator to enhance the security of an evaluation function by checking its return value.

    Args:
        func (Callable): Evaluation function to be made safer.

    Returns:
        Callable: Safer evaluation function with return value check.
    """
    ...

def safer_func(func: Callable, static_tools: dict[str, Callable] = ..., authorized_imports: list[str] = ...): # -> type | _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """
    Decorator to enhance the security of a function call by checking its return value.

    Args:
        func (Callable): Function to be made safer.
        static_tools (dict[str, Callable]): Dictionary of static tools.
        authorized_imports (list[str]): List of authorized imports.

    Returns:
        Callable: Safer function with return value check.
    """
    ...

class PrintContainer:
    def __init__(self) -> None:
        ...
    
    def append(self, text): # -> Self:
        ...
    
    def __iadd__(self, other): # -> Self:
        """Implements the += operator"""
        ...
    
    def __str__(self) -> str:
        """String representation"""
        ...
    
    def __repr__(self): # -> str:
        """Representation for debugging"""
        ...
    
    def __len__(self): # -> int:
        """Implements len() function support"""
        ...
    


class BreakException(Exception):
    ...


class ContinueException(Exception):
    ...


class ReturnException(Exception):
    def __init__(self, value) -> None:
        ...
    


def get_iterable(obj): # -> list[Any]:
    ...

def fix_final_answer_code(code: str) -> str:
    """
    Sometimes an LLM can try to assign a variable to final_answer, which would break the final_answer() tool.
    This function fixes this behaviour by replacing variable assignments to final_answer with final_answer_variable,
    while preserving function calls to final_answer().
    """
    ...

def build_import_tree(authorized_imports: list[str]) -> dict[str, Any]:
    ...

def check_import_authorized(import_to_check: str, authorized_imports: list[str]) -> bool:
    ...

def evaluate_attribute(expression: ast.Attribute, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_unaryop(expression: ast.UnaryOp, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_lambda(lambda_expression: ast.Lambda, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Callable:
    ...

def evaluate_while(while_loop: ast.While, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    ...

def create_function(func_def: ast.FunctionDef, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Callable:
    ...

def evaluate_function_def(func_def: ast.FunctionDef, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Callable:
    ...

def evaluate_class_def(class_def: ast.ClassDef, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> type:
    ...

def evaluate_annassign(annassign: ast.AnnAssign, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_augassign(expression: ast.AugAssign, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_boolop(node: ast.BoolOp, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_binop(binop: ast.BinOp, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_assign(assign: ast.Assign, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def set_value(target: ast.AST, value: Any, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    ...

def evaluate_call(call: ast.Call, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_subscript(subscript: ast.Subscript, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_name(name: ast.Name, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_condition(condition: ast.Compare, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> bool | object:
    ...

def evaluate_if(if_statement: ast.If, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_for(for_loop: ast.For, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> Any:
    ...

def evaluate_listcomp(listcomp: ast.ListComp, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> list[Any]:
    ...

def evaluate_setcomp(setcomp: ast.SetComp, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> set[Any]:
    ...

def evaluate_try(try_node: ast.Try, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    ...

def evaluate_raise(raise_node: ast.Raise, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    ...

def evaluate_assert(assert_node: ast.Assert, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    ...

def evaluate_with(with_node: ast.With, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    ...

def get_safe_module(raw_module, authorized_imports, visited=...): # -> ModuleType:
    """Creates a safe copy of a module or returns the original if it's a function"""
    ...

def evaluate_import(expression, state, authorized_imports): # -> None:
    ...

def evaluate_dictcomp(dictcomp: ast.DictComp, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> dict[Any, Any]:
    ...

def evaluate_delete(delete_node: ast.Delete, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str]) -> None:
    """
    Evaluate a delete statement (del x, del x[y]).

    Args:
        delete_node: The AST Delete node to evaluate
        state: The current state dictionary
        static_tools: Dictionary of static tools
        custom_tools: Dictionary of custom tools
        authorized_imports: List of authorized imports
    """
    ...

@safer_eval
def evaluate_ast(expression: ast.AST, state: dict[str, Any], static_tools: dict[str, Callable], custom_tools: dict[str, Callable], authorized_imports: list[str] = ...): # -> Any | tuple[Any, ...] | list[Any] | dict[Any, Any] | set[Any] | bool | object | Callable[..., Any] | str | slice[Any, Any, Any] | type | None:
    """
    Evaluate an abstract syntax tree using the content of the variables stored in a state and only evaluating a given
    set of functions.

    This function will recurse through the nodes of the tree provided.

    Args:
        expression (`ast.AST`):
            The code to evaluate, as an abstract syntax tree.
        state (`Dict[str, Any]`):
            A dictionary mapping variable names to values. The `state` is updated if need be when the evaluation
            encounters assignments.
        static_tools (`Dict[str, Callable]`):
            Functions that may be called during the evaluation. Trying to change one of these static_tools will raise an error.
        custom_tools (`Dict[str, Callable]`):
            Functions that may be called during the evaluation. These custom_tools can be overwritten.
        authorized_imports (`List[str]`):
            The list of modules that can be imported by the code. By default, only a few safe modules are allowed.
            If it contains "*", it will authorize any import. Use this at your own risk!
    """
    ...

class FinalAnswerException(Exception):
    def __init__(self, value) -> None:
        ...
    


def evaluate_python_code(code: str, static_tools: dict[str, Callable] | None = ..., custom_tools: dict[str, Callable] | None = ..., state: dict[str, Any] | None = ..., authorized_imports: list[str] = ..., max_print_outputs_length: int = ...): # -> tuple[Any | None, Literal[False]] | tuple[Any, Literal[True]]:
    """
    Evaluate a python expression using the content of the variables stored in a state and only evaluating a given set
    of functions.

    This function will recurse through the nodes of the tree provided.

    Args:
        code (`str`):
            The code to evaluate.
        static_tools (`Dict[str, Callable]`):
            The functions that may be called during the evaluation. These can also be agents in a multiagent setting.
            These tools cannot be overwritten in the code: any assignment to their name will raise an error.
        custom_tools (`Dict[str, Callable]`):
            The functions that may be called during the evaluation.
            These tools can be overwritten in the code: any assignment to their name will overwrite them.
        state (`Dict[str, Any]`):
            A dictionary mapping variable names to values. The `state` should contain the initial inputs but will be
            updated by this function to contain all variables as they are evaluated.
            The print outputs will be stored in the state under the key "_print_outputs".
    """
    ...

class PythonExecutor:
    ...


class LocalPythonExecutor(PythonExecutor):
    """
    Executor of Python code in a local environment.

    This executor evaluates Python code with restricted access to imports and built-in functions,
    making it suitable for running untrusted code. It maintains state between executions,
    allows for custom tools and functions to be made available to the code, and captures
    print outputs separately from return values.

    Args:
        additional_authorized_imports (`list[str]`):
            Additional authorized imports for the executor.
        max_print_outputs_length (`int`, defaults to `DEFAULT_MAX_LEN_OUTPUT=50_000`):
            Maximum length of the print outputs.
        additional_functions (`dict[str, Callable]`, *optional*):
            Additional Python functions to be added to the executor.
    """
    def __init__(self, additional_authorized_imports: list[str], max_print_outputs_length: int | None = ..., additional_functions: dict[str, Callable] | None = ...) -> None:
        ...
    
    def __call__(self, code_action: str) -> tuple[Any, str, bool]:
        ...
    
    def send_variables(self, variables: dict): # -> None:
        ...
    
    def send_tools(self, tools: dict[str, Tool]): # -> None:
        ...
    


__all__ = ["evaluate_python_code", "LocalPythonExecutor"]
